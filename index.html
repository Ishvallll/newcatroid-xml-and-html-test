<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Game XML Player</title>
<style>
  :root{--bg:#000;--panel:#0b0b0b;--accent:#FF7A1B;--muted:#9aa0a6;--white:#fff}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--white);font-family:Inter,system-ui,monospace;overflow:hidden;touch-action:none;}
  #stage{position:relative;width:100%;height:100vh;background:var(--bg);user-select:none}
  .caret{position:absolute;pointer-events:none;line-height:1;transform-origin:top left;font-family:monospace,system-ui}
  .asset-img{position:absolute;pointer-events:none;transform-origin:top left;image-rendering:pixelated}
  .notice{position:fixed;left:12px;bottom:12px;padding:8px 10px;background:#111;border:1px solid #222;color:var(--muted);border-radius:6px;font-size:12px}
</style>
</head>
<body>
<div id="stage"></div>
<div class="notice">Carregando game.xml…</div>

<script>
/* ---------------------------
   Config / Helpers
   --------------------------- */
const STAGE = document.getElementById('stage');
const NOTICE = document.querySelector('.notice');

function resolveAssetName(name){
  if(!name) return name;
  if(name.endsWith('.gif.png')) return name.replace(/\.gif\.png$/,'\.gif');
  return name;
}

async function fetchText(path='game.xml'){
  try{
    const r = await fetch(path, {cache:'no-store'});
    if(!r.ok) throw new Error('HTTP ' + r.status);
    return await r.text();
  }catch(e){
    console.warn('fetch error', e);
    return null;
  }
}

/* safe parse number */
function numOf(node){
  if(!node) return null;
  const v = node.querySelector('value');
  if(!v) return null;
  const n = Number(v.textContent);
  return isNaN(n) ? null : n;
}

/* Evaluate RAND-like structures seen in your XML.
   Special handling for patterns like RAND( (screenWidth - N) , N )
   Returns either a number or null if can't interpret.
*/
function evaluateRandLike(formulaNode, category, header){
  if(!formulaNode) return null;
  const t = formulaNode.querySelector('type');
  const v = formulaNode.querySelector('value');
  if(!t || t.textContent !== 'FUNCTION' || !v || v.textContent !== 'RAND') return null;

  const left = formulaNode.querySelector('leftChild');
  const right = formulaNode.querySelector('rightChild');

  // try interpret left as (screenDim - N)
  let leftVal = null;
  if(left){
    const opType = left.querySelector('type');
    const opValue = left.querySelector('value');
    if(opType && opType.textContent === 'OPERATOR' && opValue && opValue.textContent === 'MINUS'){
      const opRight = left.querySelector('rightChild');
      const n = numOf(opRight);
      if(n != null){
        const screenDim = (category === 'X_POSITION') ? Number(header.screenWidth) : Number(header.screenHeight);
        if(!isNaN(screenDim)) leftVal = screenDim - n;
      }
    } else {
      // fallback: if left contains a NUMBER anywhere
      const n = numOf(left);
      if(n != null) leftVal = n;
    }
  }

  const rightVal = numOf(right);

  if(leftVal == null || rightVal == null) return null;

  const a = Math.min(leftVal, rightVal);
  const b = Math.max(leftVal, rightVal);
  return a + Math.random() * (b - a);
}

/* extract simple NUMBER/STRING from formula node */
function extractSimple(formulaNode){
  if(!formulaNode) return null;
  const t = formulaNode.querySelector('type');
  const v = formulaNode.querySelector('value');
  if(!t || !v) return null;
  if(t.textContent === 'NUMBER') return Number(v.textContent);
  if(t.textContent === 'STRING') return v.textContent;
  return null;
}

/* clamp helper */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* ---------------------------
   Runtime: parse and run XML
   --------------------------- */
(async function main(){
  const raw = await fetchText('game.xml');
  if(!raw){
    NOTICE.textContent = 'Erro: game.xml nao encontrado.';
    return;
  }
  NOTICE.textContent = 'game.xml carregado. Interpretando...';

  const xml = new DOMParser().parseFromString(raw, 'application/xml');
  const parserError = xml.querySelector('parsererror');
  if(parserError){
    NOTICE.textContent = 'Erro no XML (veja console).';
    console.error('XML parse error', parserError);
    return;
  }

  // header (for screenWidth/screenHeight fallback)
  const headerNode = xml.querySelector('header') || {};
  const header = {
    screenWidth: headerNode.querySelector ? Number((headerNode.querySelector('screenWidth')||{textContent:window.innerWidth}).textContent) : window.innerWidth,
    screenHeight: headerNode.querySelector ? Number((headerNode.querySelector('screenHeight')||{textContent:window.innerHeight}).textContent) : window.innerHeight
  };

  // ========== StartScript: spawn initial caret if present ==========
  const startScript = xml.querySelector('script[type="StartScript"]');
  let initialProps = {x:100,y:100,size:48,color:'#fff',symbol:'^'};
  if(startScript){
    const show = startScript.querySelector('brick[type="ShowText3Brick"]');
    if(show){
      const formulas = show.querySelectorAll('formula');
      formulas.forEach(f => {
        const cat = f.getAttribute('category');
        if(cat==='X_POSITION'){ const v = extractSimple(f); if(v!=null) initialProps.x = v; }
        if(cat==='Y_POSITION'){ const v = extractSimple(f); if(v!=null) initialProps.y = v; }
        if(cat==='SIZE'){ const v = extractSimple(f); if(v!=null) initialProps.size = v; }
        if(cat==='COLOR'){ const v = extractSimple(f); if(v!=null) initialProps.color = v; }
        if(cat==='TEXT'){ const v = extractSimple(f); if(v!=null) initialProps.symbol = v; }
      });
    }
  }

  // helper: spawn caret as text
  let current = null;
  function spawnTextCaret(x, y, size=48, color='#fff', symbol='^'){
    if(current) current.remove();
    const d = document.createElement('div');
    d.className = 'caret';
    d.textContent = symbol;
    d.style.left = (x || 0) + 'px';
    d.style.top  = (y || 0) + 'px';
    d.style.color = color;
    d.style.fontSize = size + 'px';
    STAGE.appendChild(d);
    current = d;
  }

  // helper: spawn image if provided src (tries assets/<src>, resolves .gif.png -> .gif)
  async function spawnImage(src, x, y, scale=1){
    if(current) current.remove();
    const img = document.createElement('img');
    img.className = 'asset-img';
    const resolved = resolveAssetName(src);
    img.src = 'assets/' + resolved;
    img.style.left = (x||0) + 'px';
    img.style.top  = (y||0) + 'px';
    img.onload = () => {
      img.style.width = (img.naturalWidth * scale) + 'px';
      img.style.height = (img.naturalHeight * scale) + 'px';
    };
    img.onerror = () => {
      console.warn('asset nao encontrado:', resolved);
      img.remove();
      // fallback: spawn text caret if image missing
      spawnTextCaret(x,y,initialProps.size,initialProps.color, initialProps.symbol);
    };
    STAGE.appendChild(img);
    current = img;
  }

  // spawn initial (prefer image if XML defines a sprite asset for the caret)
  // check if there is a sprite in XML that is intended to be the caret (heuristic: src contains '^' name or sprite id 'caret' etc)
  // Simples: se houver <sprite id="caret" src="..."> usa asset, senão usa texto
  const caretSprite = xml.querySelector('sprite[id="caret"], sprite[id="arrow"], sprite[id="seta"]') || null;
  if(caretSprite && caretSprite.getAttribute('src')){
    spawnImage(caretSprite.getAttribute('src'), initialProps.x, initialProps.y, 1);
  } else {
    spawnTextCaret(initialProps.x, initialProps.y, initialProps.size, initialProps.color, initialProps.symbol);
  }

  // ========== WhenTouchDownScript: prepare formulas ==========
  const whenTouch = xml.querySelector('script[type="WhenTouchDownScript"]');
  let whenFormX = null, whenFormY = null, whenSize = initialProps.size, whenColor = initialProps.color, whenSymbol = initialProps.symbol, whenSpriteSrc = null;

  if(whenTouch){
    const show = whenTouch.querySelector('brick[type="ShowText3Brick"]');
    if(show){
      const formulas = show.querySelectorAll('formula');
      formulas.forEach(f => {
        const cat = f.getAttribute('category');
        if(cat === 'X_POSITION') whenFormX = f;
        if(cat === 'Y_POSITION') whenFormY = f;
        if(cat === 'SIZE'){ const v = extractSimple(f); if(v!=null) whenSize = v; }
        if(cat === 'COLOR'){ const v = extractSimple(f); if(v!=null) whenColor = v; }
        if(cat === 'TEXT'){ const v = extractSimple(f); if(v!=null) whenSymbol = v; }
      });
    }

    // also check if there's a sprite element referenced inside the WhenTouchDown script (rare)
    const spriteRef = whenTouch.querySelector('sprite');
    if(spriteRef && spriteRef.getAttribute('src')) whenSpriteSrc = spriteRef.getAttribute('src');
  }

  // click handler to spawn according to formulas (or fallback random)
  function onSpawnEvent(){
    let x = null, y = null;
    const tryX = evaluateRandLike(whenFormX, 'X_POSITION', header);
    const tryY = evaluateRandLike(whenFormY, 'Y_POSITION', header);
    if(tryX != null) x = Math.round(tryX);
    if(tryY != null) y = Math.round(tryY);

    const pad = 20;
    if(x == null) x = Math.round(Math.random() * Math.max(0, STAGE.clientWidth - pad));
    else x = clamp(x, 0, Math.max(0, STAGE.clientWidth - pad));
    if(y == null) y = Math.round(Math.random() * Math.max(0, STAGE.clientHeight - pad));
    else y = clamp(y, 0, Math.max(0, STAGE.clientHeight - pad));

    // if WhenTouch references a sprite asset, try use it
    if(whenSpriteSrc){
      spawnImage(whenSpriteSrc, x, y, 1);
    } else {
      spawnTextCaret(x, y, whenSize, whenColor, whenSymbol);
    }
  }

  // wire events (touch & click)
  STAGE.addEventListener('click', onSpawnEvent);
  STAGE.addEventListener('touchstart', (e) => { e.preventDefault(); onSpawnEvent(); }, {passive:false});
  document.addEventListener('gesturestart', e => e.preventDefault());

  NOTICE.textContent = 'Pronto — clique/touch para spawnar. (Apenas 1 instancia do ^ é mantida)';
})();
</script>
</body>
</html>
